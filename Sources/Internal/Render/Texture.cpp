#include "Render/RenderBase.h"
#include "Render/Texture.h"
#include "Utils/Utils.h"
#include "Logger/Logger.h"
#include "Debug/DVAssert.h"
#include "Utils/Utils.h"
#include "Render/Renderer.h"
#include "Utils/StringFormat.h"
#include "Time/SystemTimer.h"
#include "FileSystem/File.h"
#include "FileSystem/FileSystem.h"
#include "Scene3D/Systems/QualitySettingsSystem.h"
#include "Render/RenderHelper.h"

#if defined(__DAVAENGINE_IPHONE__)
#include <CoreGraphics/CoreGraphics.h>
#include <CoreFoundation/CoreFoundation.h>
#elif defined(__DAVAENGINE_MACOS__)
#include <ApplicationServices/ApplicationServices.h>
#endif //PLATFORMS

#include "Render/Image/Image.h"
#include "Render/Image/ImageSystem.h"
#include "Render/Image/ImageConvert.h"
#include "Render/RHI/Common/rhi_Utils.h"

#include "Render/TextureDescriptor.h"
#include "Render/GPUFamilyDescriptor.h"

#include "Render/RHI/Common/rhi_Utils.h"

#include "Math/MathHelpers.h"
#include "Concurrency/LockGuard.h"

#define DAVA_DEBUG_TEXTURE_DISABLE_LOADING 0

namespace DAVA
{

Array<String, Texture::CUBE_FACE_COUNT> Texture::FACE_NAME_SUFFIX =
{ {
String("_px"),
String("_nx"),
String("_py"),
String("_ny"),
String("_pz"),
String("_nz")
} };

Texture::Texture(const Any& assetKey)
    : AssetBase(assetKey)
{
    DAVA_MEMORY_PROFILER_CLASS_ALLOC_SCOPE();

    texDescriptor = new TextureDescriptor();
}

Texture::~Texture()
{
    ReleaseTextureData();
    SafeDelete(texDescriptor);
}

void Texture::ReleaseTextureData()
{
    if (handle.IsValid())
    {
        rhi::DeleteTexture(handle);
        handle = rhi::HTexture(rhi::InvalidHandle);
    }

    if (samplerStateHandle.IsValid())
    {
        rhi::ReleaseSamplerState(samplerStateHandle);
        samplerStateHandle = rhi::HSamplerState(rhi::InvalidHandle);
    }

    if (singleTextureSet.IsValid())
    {
        rhi::ReleaseTextureSet(singleTextureSet);
        singleTextureSet = rhi::HTextureSet(rhi::InvalidHandle);
    }

    state = STATE_INVALID;
    isRenderTarget = false;
}

void Texture::TexImage(int32 level, uint32 width, uint32 height, const void* _data, uint32 dataSize, uint32 cubeFaceId)
{
    rhi::UpdateTexture(handle, _data, level, rhi::TextureFace(cubeFaceId));
}

void Texture::SetWrapMode(rhi::TextureAddrMode wrapU, rhi::TextureAddrMode wrapV, rhi::TextureAddrMode wrapW)
{
    samplerState.addrU = wrapU;
    samplerState.addrV = wrapV;
    samplerState.addrW = wrapW;

    rhi::ReleaseSamplerState(samplerStateHandle);
    samplerStateHandle = CreateSamplerStateHandle(samplerState);
}

void Texture::SetMinMagFilter(rhi::TextureFilter minFilter, rhi::TextureFilter magFilter, rhi::TextureMipFilter mipFilter)
{
    samplerState.minFilter = minFilter;
    samplerState.magFilter = magFilter;
    samplerState.mipFilter = mipFilter;

    rhi::ReleaseSamplerState(samplerStateHandle);
    samplerStateHandle = CreateSamplerStateHandle(samplerState);
}

void Texture::SetDebugInfo(const String& _debugInfo)
{
#if defined(__DAVAENGINE_DEBUG__)
    debugInfo = FastName(_debugInfo.c_str());
#endif
}

Image* Texture::CreateImageFromRegion(const Rect2i& rect, uint32 level)
{
    DAVA_MEMORY_PROFILER_CLASS_ALLOC_SCOPE();

    int32 readWidth = (rect.dx == -1) ? (width - rect.x) : rect.dx;
    int32 readHeight = (rect.dy == -1) ? (height - rect.y) : rect.dy;

    Image* image = Image::Create(readWidth, readHeight, texDescriptor->format);
    rhi::ReadTextureRegion(handle, image->data, image->dataSize, Rect2i(rect.x, rect.y, readWidth, readHeight), level);

    return image;
}

uint32 Texture::GetDataSize() const
{
    DVASSERT((0 <= texDescriptor->format) && (texDescriptor->format < FORMAT_COUNT));

    uint32 allocSize = width * height * PixelFormatDescriptor::GetPixelFormatSizeInBits(texDescriptor->format) / 8;
    return allocSize;
}

bool Texture::IsPinkPlaceholder() const
{
    return isPink;
}

const FilePath& Texture::GetPathname() const
{
    return texDescriptor->pathname;
}

PixelFormat Texture::GetFormat() const
{
    return texDescriptor->format;
}

uint32 Texture::GetMipLevelsCount() const
{
    DVASSERT(autoGeneratedMips == false);
    return levelsCount;
}

void Texture::CreateCubemapMipmapImages(Vector<Vector<Image*>>& images, uint32 mipmapLevelCount)
{
    DVASSERT(textureType == rhi::TEXTURE_TYPE_CUBE);

    images.reserve(Texture::CUBE_FACE_COUNT);
    for (uint32 i = 0; i < Texture::CUBE_FACE_COUNT; ++i)
    {
        images.emplace_back();
        Vector<Image*>& mipmapImages = images.back();
        mipmapImages.reserve(mipmapLevelCount);

        for (uint32 mipLevel = 0; mipLevel < mipmapLevelCount; ++mipLevel)
        {
            Size2i levelSize = rhi::TextureExtents(Size2i(width, height), mipLevel);
            void* data = rhi::MapTexture(handle, mipLevel, static_cast<rhi::TextureFace>(i));
            Image* image = Image::CreateFromData(levelSize.dx, levelSize.dy, texDescriptor->format, reinterpret_cast<uint8*>(data));
            image->mipmapLevel = mipLevel;
            image->cubeFaceID = i;
            rhi::UnmapTexture(handle);

            mipmapImages.emplace_back(image);
        }
    }
}

rhi::HSamplerState Texture::CreateSamplerStateHandle(const rhi::SamplerState::Descriptor::Sampler& samplerState)
{
    rhi::SamplerState::Descriptor samplerDesc;

    samplerDesc.fragmentSampler[0] = samplerState;
    samplerDesc.fragmentSamplerCount = 1;

    return rhi::AcquireSamplerState(samplerDesc);
}

template <>
bool AnyCompare<Texture::PathKey>::IsEqual(const Any& v1, const Any& v2)
{
    return v1.Get<Texture::PathKey>() == v2.Get<Texture::PathKey>();
}

template <>
bool AnyCompare<Texture::UniqueTextureKey>::IsEqual(const Any& v1, const Any& v2)
{
    return v1.Get<Texture::UniqueTextureKey>().uniqueKey == v2.Get<Texture::UniqueTextureKey>().uniqueKey;
}

template <>
bool AnyCompare<Texture::RenderTargetTextureKey>::IsEqual(const Any& v1, const Any& v2)
{
    return v1.Get<Texture::RenderTargetTextureKey>() == v2.Get<Texture::RenderTargetTextureKey>();
}
};
